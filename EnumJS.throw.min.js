/**github.com/ChuckTerry/EnumJS,AGPL-3.0*/
class Enum {#a;#b;#c;#d;static from(){return new Enum(Array.from(arguments))};static isEnum(a){return a instanceof Enum};constructor(){if(arguments.lentgh<1){throw new TypeError(`Enum construction requires a minimum of One (1) parameter`)};this.#d=Array.from(arguments);this.#a=this.#d[0];this.#b=false;this.#c=Symbol(`a`)};#A(){return this.#a};#B(a){return this.#d.indexOf(a)};#C(){return !!this.#b};[Symbol.iterator](){let a=0;return ({next:()=>{return ((a<this.#d.length)?{value:this.#d[a++],done:false}:{done:true})}})};[Symbol.search](string){return this.#B(string)};[Symbol.toPrimitive](a){return (a[0]===`n`)?this.#B(this.#a):this.#a.toString()};[Symbol.toStringTag](){return `Enum`};get length(){return this.#d.length};set length(a){return a===this.#c};get state(){return this.#A()};set state(state){return this.setState(state)};get states(){return this.getValidStates()};set states(a){return a===this.#c};get value(){return this.#A()};set value(a){return this.setState(a)};forEach(){return this.#d.forEach([...arguments])};getState(){return this.#A()};getValidStates(){return this.#d};indexOf(a){return this.#d.indexOf(a)};isLocked(){return this.#C()};isValidState(a){return this.indexOf(a)>-1};lock(a){if(this.#C()) throw new Error(`Enum is already locked`);this.#b=true;this.#c=Symbol(`A`);return (a)?true:this.#c};setState(a){if(!this.isValidState(a))throw new RangeError(`"${a}" is not a valid state`);if(this.#C())throw new TypeError(`State cannot be changed on Enum in locked state`);return this.#a=a};unlock(a){if(!this.#C())throw new Error(`Enum is already unlocked`);if(a!==this.#c)throw new TypeError(`Invalid key to unlock Enum`);this.#b=false;return this.#c=null};valueOf(){return this.#A()}}
